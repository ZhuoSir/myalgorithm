package com.chen.leetcode.math;

import org.junit.Test;

/**
 * 实现 pow(x, n) ，即计算 x 的 n 次幂函数。
 * <p>
 * 示例 1:
 * <p>
 * 输入: 2.00000, 10
 * 输出: 1024.00000
 * 示例 2:
 * <p>
 * 输入: 2.10000, 3
 * 输出: 9.26100
 * 示例 3:
 * <p>
 * 输入: 2.00000, -2
 * 输出: 0.25000
 * 解释: 2-2 = 1/22 = 1/4 = 0.25
 * 说明:
 * <p>
 * -100.0 < x < 100.0
 * n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。
 * <p>
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/powx-n
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 */
public class $50 {

    /**
     * 方法一：快速幂 + 递归
     * 「快速幂算法」的本质是分治算法。举个例子，如果我们要计算 x^{64}x
     * 64
     * ，我们可以按照：
     * <p>
     * x \to x^2 \to x^4 \to x^8 \to x^{16} \to x^{32} \to x^{64}
     * x→x
     * 2
     * →x
     * 4
     * →x
     * 8
     * →x
     * 16
     * →x
     * 32
     * →x
     * 64
     * <p>
     * <p>
     * 的顺序，从 xx 开始，每次直接把上一次的结果进行平方，计算 66 次就可以得到 x^{64}x
     * 64
     * 的值，而不需要对 xx 乘 6363 次 xx。
     * <p>
     * 再举一个例子，如果我们要计算 x^{77}x
     * 77
     * ，我们可以按照：
     * <p>
     * x \to x^2 \to x^4 \to x^9 \to x^{19} \to x^{38} \to x^{77}
     * x→x
     * 2
     * →x
     * 4
     * →x
     * 9
     * →x
     * 19
     * →x
     * 38
     * →x
     * 77
     * <p>
     * <p>
     * 的顺序，在 x \to x^2x→x
     * 2
     * ，x^2 \to x^4x
     * 2
     * →x
     * 4
     * ，x^{19} \to x^{38}x
     * 19
     * →x
     * 38
     * 这些步骤中，我们直接把上一次的结果进行平方，而在 x^4 \to x^9x
     * 4
     * →x
     * 9
     * ，x^9 \to x^{19}x
     * 9
     * →x
     * 19
     * ，x^{38} \to x^{77}x
     * 38
     * →x
     * 77
     * 这些步骤中，我们把上一次的结果进行平方后，还要额外乘一个 xx。
     * <p>
     * 直接从左到右进行推导看上去很困难，因为在每一步中，我们不知道在将上一次的结果平方之后，还需不需要额外乘 xx。但如果我们从右往左看，分治的思想就十分明显了：
     * <p>
     * 当我们要计算 x^nx
     * n
     * 时，我们可以先递归地计算出 y = x^{\lfloor n/2 \rfloor}y=x
     * ⌊n/2⌋
     * ，其中 \lfloor a \rfloor⌊a⌋ 表示对 aa 进行下取整；
     * <p>
     * 根据递归计算的结果，如果 nn 为偶数，那么 x^n = y^2x
     * n
     * =y
     * 2
     * ；如果 nn 为奇数，那么 x^n = y^2 * xx
     * n
     * =y
     * 2
     * ∗x；
     * <p>
     * 递归的边界为 n = 0n=0，任意数的 00 次方均为 11。
     * <p>
     * 由于每次递归都会使得指数减少一半，因此递归的层数为 O(\log n)O(logn)，算法可以在很快的时间内得到结果。
     * <p>
     * 作者：LeetCode-Solution
     * 链接：https://leetcode-cn.com/problems/powx-n/solution/powx-n-by-leetcode-solution/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     * <p>
     * 复杂度分析
     * <p>
     * 时间复杂度：O(\log n)O(logn)，即为递归的层数。
     * <p>
     * 空间复杂度：O(\log n)O(logn)，即为递归的层数。这是由于递归的函数调用会使用栈空间。
     */
    public double myPow(double x, int n) {

        return n > 0 ? calculate2(x, n) : 1 / calculate2(x, -n);
    }

    /**
     * 方法二：快速幂 + 迭代
     * 由于递归需要使用额外的栈空间，我们试着将递归转写为迭代。在方法一中，我们也提到过，从左到右进行推导是不容易的，因为我们不知道是否需要额外乘 xx。但我们不妨找一找规律，看看哪些地方额外乘了 xx，并且它们对答案产生了什么影响。
     * <p>
     * 我们还是以 x^{77}x
     * 77
     * 作为例子：
     * <p>
     * x \to x^2 \to x^4 \to^+ x^9 \to^+ x^{19} \to x^{38} \to^+ x^{77}
     * x→x
     * 2
     * →x
     * 4
     * →
     * +
     * x
     * 9
     * →
     * +
     * x
     * 19
     * →x
     * 38
     * →
     * +
     * x
     * 77
     * <p>
     * <p>
     * 并且把需要额外乘 xx 的步骤打上了 ++ 标记。可以发现：
     * <p>
     * x^{38} \to^+ x^{77}x
     * 38
     * →
     * +
     * x
     * 77
     * 中额外乘的 xx 在 x^{77}x
     * 77
     * 中贡献了 xx；
     * <p>
     * x^9 \to^+ x^{19}x
     * 9
     * →
     * +
     * x
     * 19
     * 中额外乘的 xx 在之后被平方了 22 次，因此在 x^{77}x
     * 77
     * 中贡献了 x^{2^2} = x^4x
     * 2
     * 2
     * <p>
     * =x
     * 4
     * ；
     * <p>
     * x^4 \to^+ x^9x
     * 4
     * →
     * +
     * x
     * 9
     * 中额外乘的 xx 在之后被平方了 33 次，因此在 x^{77}x
     * 77
     * 中贡献了 x^{2^3} = x^8x
     * 2
     * 3
     * <p>
     * =x
     * 8
     * ；
     * <p>
     * 最初的 xx 在之后被平方了 66 次，因此在 x^{77}x
     * 77
     * 中贡献了 x^{2^6} = x^{64}x
     * 2
     * 6
     * <p>
     * =x
     * 64
     * 。
     * <p>
     * 我们把这些贡献相乘，x * x^4 * x^8 * x^{64}x∗x
     * 4
     * ∗x
     * 8
     * ∗x
     * 64
     * 恰好等于 x^{77}x
     * 77
     * 。而这些贡献的指数部分又是什么呢？它们都是 22 的幂次，这是因为每个额外乘的 xx 在之后都会被平方若干次。而这些指数 11，44，88 和 6464，恰好就对应了 7777 的二进制表示 (1001101)_2(1001101)
     * 2
     * ​
     * 中的每个 11！
     * <p>
     * 因此我们借助整数的二进制拆分，就可以得到迭代计算的方法，一般地，如果整数 nn 的二进制拆分为
     * <p>
     * n = 2^{i_0} + 2^{i_1} + \cdots + 2^{i_k}
     * n=2
     * i
     * 0
     * ​
     * <p>
     * +2
     * i
     * 1
     * ​
     * <p>
     * +⋯+2
     * i
     * k
     * ​
     * <p>
     * <p>
     * <p>
     * 那么
     * <p>
     * x^n = x^{2^{i_0}} * x^{2^{i_1}} * \cdots * x^{2^{i_k}}
     * x
     * n
     * =x
     * 2
     * i
     * 0
     * ​
     * <p>
     * <p>
     * ∗x
     * 2
     * i
     * 1
     * ​
     * <p>
     * <p>
     * ∗⋯∗x
     * 2
     * i
     * k
     * ​
     * <p>
     * <p>
     * <p>
     * <p>
     * 这样以来，我们从 xx 开始不断地进行平方，得到 x^2, x^4, x^8, x^{16}, \cdotsx
     * 2
     * ,x
     * 4
     * ,x
     * 8
     * ,x
     * 16
     * ,⋯，如果 nn 的第 kk 个（从右往左，从 00 开始计数）二进制位为 11，那么我们就将对应的贡献 x^{2^k}x
     * 2
     * k
     * <p>
     * 计入答案。
     * <p>
     * 作者：LeetCode-Solution
     * 链接：https://leetcode-cn.com/problems/powx-n/solution/powx-n-by-leetcode-solution/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     * <p>
     * 复杂度分析
     * <p>
     * 时间复杂度：O(\log n)O(logn)，即为对 nn 进行二进制拆分的时间复杂度。
     * <p>
     * 空间复杂度：O(1)O(1)。
     */
    public double calculate(double x, int n) {

        if (n == 0)
            return 1.0;

        double res = calculate(x, n / 2);

        return n % 2 == 0 ? res * res : res * res * x;

    }

    public double calculate2(double x, int n) {

        if (n == 0)
            return 1.0;

        double res = 1.0;
        double xtmp = x;
        while (n > 0) {
            if (n % 2 == 1) {
                res = res * xtmp;
            }

            xtmp *= xtmp;
            n = n / 2;
        }

        return res;
    }


    @Test
    public void test() {

        System.out.println(myPow(2, 2));

    }
}
